\section{Introduction}
\label{introduction}

Structure editors are an alternative to the standard text editors that
eliminate the occurrence of syntax errors by working directly with an
abstract syntax tree (AST) and can also be used to give a more intuitive
visualization of the program code.

An early example of a structure editor is the Cornell Program Synthesizer
from 1981 \cornell. It directly edits the ASTs in programs by using a cursor to
select nodes and allows for insertions and modifications at the cursor. This
editor was not typed meaning that it allowed ill-typed ASTs to be built.

A later example is Hazelnut from 2017 \hazel. It is a bidirectionally typed
structure editor on ASTs, where it introduces holes that represent uncompleted
subtrees. It has dynamic semantics and type consistency of holes are not
checked until the hole is built to completeness. The result is that for
uncompleted programs the completed parts can still be evaluated and the holes
can still be meaningful, even when they are not well-typed.

In their 2020 paper Godiksen et al. \pepm~described an editor calculus
inspired by Hazelnut. The calculus describes the edit actions of a 
typed structure editor on terms of a simply-typed lambda
calculus. The calculus allows for partial evaluation of terms by means
of breakpoints and like Hazelnut, terms can be incomplete in the form
of holes. However, unlike Hazelnut, the calculus incorporates recursive
behaviours and a very expressive spatial logic on ASTs. The type
system of the calculus guarantees that well-typed editor expressions
will always construct well-typed programs.

In this paper we demonstrate that the editor calculus can serve as the
basis of a structure editor by means of an implementation in
Elm. This implementation effort involves an implementation of the
spatial logic as well as the underlying type system.

In order to create editor expressions that are used to traverse and modify the
ASTs, we introduce an editor expression builder that allows us to
iteratively build editor expressions.

This paper is structured as follows
. Preliminaries are listed in section
\ref{preliminaries}. The overall principles of Godiksen et al.s editor calculus
are described in section \ref{principles}. In section \ref{design} we introduce
the design of the implementation. Section \ref{modeling} is about how we model
the calculus terms, types and the editor expression builder. The evaluation
rules are defined in section \ref{evaluation} together with implementation and
execution of said rules. In section \ref{type-checking} we define the type
rules and describe the implementation of the type checker. We discuss the user
interface and how it combines the calculus in section \ref{user-interface}. In
the last section - section \ref{conclusion} - we conclude our project and
discuss future work.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../pepm2023"
%%% End:
